-- Disable background colors for LSP document colors (Tailwind CSS, etc.)
-- NOTE: Important if you use Neovim Nightly; otherwise, comment this out.
vim.api.nvim_create_autocmd('LspAttach', {
  callback = function()
    vim.lsp.document_color.enable(false)
  end,
})

-- Disable a winbar for terminal buffers (Dropbar)
-- vim.api.nvim_create_autocmd({ 'BufEnter', 'WinEnter' }, {
--   callback = function(args)
--     local buf = args.buf
--     if vim.bo[buf].buftype == 'terminal' then
--       vim.schedule(function()
--         if vim.api.nvim_buf_is_valid(buf) then
--           vim.opt_local.winbar = ''
--
--           vim.cmd 'redraw!'
--
--           vim.cmd 'startinsert'
--         end
--       end)
--     end
--   end,
-- })

-- Trigger the Snacks picker if Neovim is started with a single directory as an argument
vim.api.nvim_create_autocmd('VimEnter', {
  callback = function()
    local arg = vim.fn.argv(0)
    if vim.fn.argc() == 1 and vim.fn.isdirectory(arg) == 1 then
      Snacks.picker.smart()
      -- vim.cmd 'FzfLua files'
    end
  end,
})

--last cursor position
local restore_last_pos = false
if restore_last_pos then
  local grp = vim.api.nvim_create_augroup('LastCursorPos', { clear = true })

  vim.api.nvim_create_autocmd('BufReadPost', {
    group = grp,
    callback = function(event)
      local buf = event.buf
      local exclude = { 'gitcommit', 'gitrebase' }

      if vim.tbl_contains(exclude, vim.bo[buf].filetype) or vim.b[buf].last_cursor_restored then
        return
      end

      vim.b[buf].last_cursor_restored = true

      local mark = vim.api.nvim_buf_get_mark(buf, '"')
      local line_count = vim.api.nvim_buf_line_count(buf)

      if mark[1] > 0 and mark[1] <= line_count then
        pcall(vim.api.nvim_win_set_cursor, 0, mark)
      end
    end,
  })
end

-- Initialize spell checking on buffer read
local spell_enabled_on_start = false
local spell_group = vim.api.nvim_create_augroup('SpellByDefault', { clear = true })

vim.api.nvim_create_autocmd({ 'BufEnter', 'FileType' }, {
  group = spell_group,
  pattern = { 'markdown', '*.md', 'text' },
  callback = function()
    vim.opt_local.spell = spell_enabled_on_start
  end,
})

vim.api.nvim_create_autocmd('FileType', {
  pattern = 'dashboard',
  command = 'setlocal nolist',
})

vim.api.nvim_create_autocmd('TextYankPost', {
  desc = 'Highlight when yanking (copying) text',
  group = vim.api.nvim_create_augroup('kickstart-highlight-yank', { clear = true }),
  callback = function()
    vim.highlight.on_yank()
  end,
})

-- Syntax highlighting for dotenv files
local enable_dotenv_syntax = true

if enable_dotenv_syntax then
  local dotenv_ft = vim.api.nvim_create_augroup('dotenv_ft', { clear = true })

  vim.api.nvim_create_autocmd('BufRead', {
    group = dotenv_ft,
    pattern = { '.env*', '.env' },
    callback = function()
      vim.bo.filetype = 'dosini'
    end,
  })
end

-- Disable auto comment continuation on new lines
local disable_auto_comment_continuation = true

if disable_auto_comment_continuation then
  local no_auto_comment = vim.api.nvim_create_augroup('no_auto_comment', { clear = true })

  vim.api.nvim_create_autocmd('FileType', {
    group = no_auto_comment,
    callback = function()
      vim.opt_local.formatoptions:remove { 'c', 'r', 'o' }
    end,
  })
end

--Auto Save
local enable_autosave = true

if enable_autosave then
  local group = vim.api.nvim_create_augroup('kickstart-autosave', { clear = true })

  vim.api.nvim_create_autocmd({ 'FocusLost', 'BufLeave' }, {
    group = group,
    callback = function()
      vim.cmd 'silent! update'
    end,
  })
end

-- ToggleTerm
function _G.set_terminal_keymaps()
  local opts = { buffer = 0 }
  vim.keymap.set('t', '<esc>', [[<C-\><C-n>]], opts)
  vim.keymap.set('t', 'jk', [[<C-\><C-n>]], opts)
  vim.keymap.set('t', '<C-h>', [[<Cmd>wincmd h<CR>]], opts)
  vim.keymap.set('t', '<C-j>', [[<Cmd>wincmd j<CR>]], opts)
  vim.keymap.set('t', '<C-k>', [[<Cmd>wincmd k<CR>]], opts)
  vim.keymap.set('t', '<C-l>', [[<Cmd>wincmd l<CR>]], opts)
  vim.keymap.set('t', '<C-w>', [[<C-\><C-n><C-w>]], opts)
end

vim.cmd [[
  augroup ToggleTermKeymaps
    autocmd!
    autocmd TermOpen term://*toggleterm#* lua set_terminal_keymaps()
  augroup END
]]

-- Snacks Explorer
local SNACKS_START_WITH_EXPLORER = false
local SNACKS_FOCUS_EXPLORER = false

if SNACKS_START_WITH_EXPLORER then
  local function is_opened_with_dot()
    if vim.fn.argc() == 1 then
      local arg = vim.fn.argv(0)
      local arg_path = vim.fn.fnamemodify(arg, ':p'):gsub('/$', '')
      local cwd = vim.fn.getcwd():gsub('/$', '')
      return arg == '.' or arg_path == cwd
    end
    return false
  end

  local opened_with_dot = is_opened_with_dot()

  local function focus_buffer_after_snacks(bufnr)
    local attempts = 0
    local function try_focus()
      if vim.api.nvim_buf_is_valid(bufnr) then
        local current_buf = vim.api.nvim_get_current_buf()
        if current_buf ~= bufnr then
          vim.api.nvim_set_current_buf(bufnr)
        end
      end
      attempts = attempts + 1
      if attempts < 10 then
        vim.defer_fn(try_focus, 15)
      end
    end
    try_focus()
  end

  vim.api.nvim_create_autocmd('VimEnter', {
    callback = function()
      if opened_with_dot then
        return
      end

      if vim.fn.argc() == 1 then
        local arg = vim.fn.argv(0)
        if vim.fn.isdirectory(arg) == 1 then
          local ok, snacks = pcall(require, 'snacks')
          if ok and snacks and snacks.explorer then
            local bufnr = vim.api.nvim_get_current_buf()
            snacks.explorer()
            if not SNACKS_FOCUS_EXPLORER then
              focus_buffer_after_snacks(bufnr)
            end
          end
        end
      end
    end,
  })

  vim.api.nvim_create_autocmd('BufReadPost', {
    once = true,
    callback = function(args)
      if opened_with_dot then
        return
      end

      local bufname = vim.api.nvim_buf_get_name(args.buf)
      local path = args.file or ''

      if bufname == '' or bufname:match 'snacks_picker_input' or bufname:match 'NvimTree_' or bufname:match '^%[.*%]$' or path:match '/nvim%.phrosa/' then
        return
      end

      local ok, snacks = pcall(require, 'snacks')
      if ok and snacks and snacks.explorer then
        local bufnr = args.buf
        snacks.explorer()
        if not SNACKS_FOCUS_EXPLORER then
          focus_buffer_after_snacks(bufnr)
        end
      end
    end,
  })
end

-- Relative Number
local enable_relative_number_toggle = false

if enable_relative_number_toggle then
  vim.api.nvim_create_augroup('RelativeNumberToggle', { clear = true })

  vim.api.nvim_create_autocmd({ 'InsertLeave', 'BufEnter', 'FocusGained' }, {
    group = 'RelativeNumberToggle',
    callback = function()
      if vim.o.number then
        vim.wo.relativenumber = true
      end
    end,
  })

  vim.api.nvim_create_autocmd({ 'InsertEnter', 'BufLeave', 'FocusLost' }, {
    group = 'RelativeNumberToggle',
    callback = function()
      vim.wo.relativenumber = false
    end,
  })
end

-- Highlight LSP references
local enable_custom_reference_highlights = true

if enable_custom_reference_highlights then
  local my_highlights = vim.api.nvim_create_augroup('MyHighlights', { clear = true })

  vim.api.nvim_create_autocmd('ColorScheme', {
    group = my_highlights,
    pattern = '*',
    callback = function()
      local highlight_style = { bold = true, bg = 'none', fg = '#FFFFFF' }

      vim.api.nvim_set_hl(0, 'LspReferenceRead', highlight_style)
      vim.api.nvim_set_hl(0, 'LspReferenceWrite', highlight_style)
      vim.api.nvim_set_hl(0, 'LspReferenceText', highlight_style)
    end,
  })
end

-- DBUI NO FOLDING
local enable_dbout_no_folding = true

if enable_dbout_no_folding then
  vim.api.nvim_create_autocmd('FileType', {
    pattern = 'dbout',
    callback = function()
      vim.cmd 'normal! zR'
    end,
  })
end

-- Notify AutoSave status
-- vim.schedule(function()
--   local message = enable_autosave and 'AutoSave enabled ⚡' or 'AutoSave disabled ⛔'
--   local level = enable_autosave and vim.log.levels.INFO or vim.log.levels.WARN
--   vim.notify(message, level, { title = 'Neovim', timeout = 2000 })
-- end)
